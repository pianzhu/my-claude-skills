---
name: problem-solution-dialogue
description: Use when the user explicitly invokes this skill to discuss an issue and choose the best approach among multiple options, especially when requirements, constraints, or tradeoffs are unclear.
---

# 与用户共创问题解决方案

## 概述

这是一个“先把问题定义对，再把方案选对”的对话流程：先补齐上下文，再用溯因 + 系统思考 + 演绎推理形成可验证的方案集，最后用事前验尸逼出关键漏洞并回退修正。

<output_verbosity_spec>
- 默认不显式输出逐步思维过程；只输出关键结论（假设/断言/验证动作/风险与护栏）。
- 第 3 步必须输出 ASCII 系统回路图；除图外，说明文字保持极简。
- 仅当用户明确要求“展开推理过程/为什么这么判断”时，才补充关键依据（摘要式）。
</output_verbosity_spec>

<design_and_scope_constraints>
- 仅在用户显式点名/调用本技能时使用；不要因任务相似而自动启用。
- 本技能用于讨论问题、分析权衡、形成可验证方案集与落地计划；不做未被请求的实现改动。
- 严格按 1–7 步执行；未满足阶段门则不进入后续步骤。
</design_and_scope_constraints>

<user_updates_spec>
- 仅在阶段切换（1/5/6/7）用 1–2 句更新进度与当前阻塞点。
- 遇到关键不确定性先停下来追问，避免带着错误前提继续推进。
</user_updates_spec>

## 何时使用 / 不使用

说明：下述内容用于用户或上层调度判断是否要“显式调用”本技能；本技能不自行判断触发。

使用场景（触发信号）：
- 用户说“帮我分析一下最佳方案/怎么做更好/选哪个架构”，但目标、约束、成功标准不清晰
- 明显存在多解与权衡（成本/风险/性能/组织协作/上线节奏）
- 用户给出症状但根因不明，需要先做溯因推理与验证路径

不适用：
- 用户给出明确规格并要求直接落地实现（优先走工程化实施类技能/流程）
- 仅需一个事实性答案或单点知识查询（直接回答即可）

## 快速流程（7 步）

1) 上下文获取：调用 `ask-questions-if-underspecified`
2) 溯因推理：构造 2–3 个假设并优先验证最可能
3) 系统思考：画出关键反馈回路（ASCII 系统图）
4) 演绎推理：自上而下拆解（有条件则用 sequential thinking 工具）
5) 方案集：给出 2–3 个可选方案 + 推荐
6) 事前验尸：对用户选定方案找 3–5 个漏洞，并按严重程度回退到对应节点修正
7) 计划落地：调用 `planning-with-files` 输出详细计划

## 1) 上下文获取（只负责“调用”，不在此做判断）

**REQUIRED SUB-SKILL:** `ask-questions-if-underspecified`

执行规则：
- 先调用 `ask-questions-if-underspecified`；严格按其输出的问题逐个推进
- 在上下文未补齐前，不进入第 2–7 步（除非该子技能明确允许先给临时路径）

缺失兜底（仅当子技能不可用时启用）：
- 只问 1 个关键问题：本议题的“成功标准”是什么（可量化优先）？

## 2) 溯因推理（Abductive）

目标：把“症状 → 可能原因 → 最小验证动作”串成可证伪链路。

输出约束：遵循 `<output_verbosity_spec>`。

执行清单：
- 构造 2–3 个合理假设（按可能性排序）
- 对最可能假设给出 1 个最小验证动作（日志/指标/复现实验/对照组）
- 同时保留 1 个低概率但高风险假设，给出“早期预警信号/护栏”
- 当用户否定前提或出现关键疑点：显式回退，更新假设集合与方案

## 3) 系统思考（广角镜 + 反馈回路）

回答两个问题：
- 这个议题处在一张怎样的网络之中（关键要素/参与方/约束）？
- 驱动它运行的、最关键的反馈回路是什么（增强 R / 调节 B）？

输出约束：遵循 `<output_verbosity_spec>`。

系统图要求（必须用 ASCII 放在代码块内）：
- 用 `-->` 表示因果方向
- 用 `(R)` 标增强回路，`(B)` 标调节回路

模板：
```text
  [目标指标] --> [策略/动作] --> [中间变量] --> [结果]
        ^                                   |
        |                                   v
     [副作用/成本] <--------------------- (B/R)
```

## 4) 演绎推理（Deductive）

优先规则：
- 如果可用：使用 sequential thinking 工具，做自上而下的分解与结论推导
- 如果不可用：用“结论 → 依据 → 反例/边界 → 可验证预测”的顺序写出来

输出约束：遵循 `<output_verbosity_spec>`。

最低输出要求：
- 列出 3–7 条关键断言（每条都要可证伪）
- 每条断言都给出验证方式（数据/实验/检查点）

## 5) 输出 2–3 个方案（让用户选）

每个方案至少包含：
- 核心思路（1 句话）
- 适用前提 / 不适用边界
- 主要收益与主要风险（各 1–3 条）
- 最小落地路径（第一周/第一步做什么）

同时给出你的推荐，并说明推荐依赖的关键假设是什么。

阶段门：在用户明确选择方案前，**必须停止并等待用户选择**，不要进入第 6 步。

## 6) 事前验尸（Pre-mortem）+ 回退策略（关键步骤）

对“用户选择的方案”做事前验尸：
- 假设 3–6 个月后失败了：列出 3–5 个最可能的失败模式（漏洞）
- 对每个漏洞：给出触发条件、早期信号、缓解/降级手段

按严重程度回退到节点（必须显式说明回退原因）：
- **信息缺失/目标不清** → 回退到第 1 步
- **关键因果链/外部约束判断错误** → 回退到第 3 步
- **假设被证伪/根因链断裂** → 回退到第 2 步
- **方案权衡/边界条件不成立** → 回退到第 5 步

阶段门：进入第 7 步前，必须与用户确认：
- 哪些漏洞已缓解（对应措施是什么）
- 哪些漏洞选择接受（代价/护栏/早期信号是什么）

确认完成后，**必须停止并等待用户同意继续**，再进入第 7 步。

## 7) 生成可执行计划（文件级）

**REQUIRED SUB-SKILL:** `planning-with-files`

本节不自行尝试生成计划细节；直接调用 `planning-with-files` 产出文件级计划即可。

## 压力场景测试（RED/GREEN 复用）

目的：防止在时间压力/信息不足/用户强推结论时跳过关键步骤。

场景 A（信息不足 + 要求立刻给结论）：
- 用户： “我们服务延迟变高了，给我一个最佳方案，今天就要定。”
- **RED（无技能的典型失败）**：直接给“加缓存/加机器/调数据库”泛化建议；不定义指标与验证路径。
- **GREEN（使用本技能）**：先走第 1 步，补齐成功标准与最小验证，再给 2–3 方案与事前验尸。

场景 B（多解权衡 + 用户只要一个答案）：
- 用户： “选微服务还是单体？别给我太多选项。”
- **RED**：迎合只给一个答案，忽略前提与边界。
- **GREEN**：仍给 2–3 方案，但用更短对比表呈现，并标注推荐依赖的关键假设。

场景 C（根因不明 + 低概率高风险）：
- 用户： “偶发数据错乱，但复现不了，先别管它。”
- **RED**：把“不可复现”当作“可忽略”，不设护栏。
- **GREEN**：第 2 步保留低概率高风险假设，给早期信号与护栏；第 6 步明确降级/隔离策略。

## 常见错误（自检清单）

- 跳过第 1 步直接给方案（尤其在用户催促时）
- 第 2 步只列假设不写“最小验证动作”
- 第 3 步只画组件图，不指出关键反馈回路（R/B）
- 第 5 步只给推荐，不给可选项与边界
- 第 6 步只列漏洞，不回退修正或不把漏洞转成监控/护栏
- 在第 2–4 步输出过多“逐步思维过程”，把对话变成冗长自言自语（默认只给关键前提/断言/验证）
